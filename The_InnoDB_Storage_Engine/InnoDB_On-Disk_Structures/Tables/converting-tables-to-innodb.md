## 15.6.1.3 把表的存储引擎从MyISAM切换为InnoDB

> 原文地址：[https://dev.mysql.com/doc/refman/8.0/en/converting-tables-to-innodb.html](https://dev.mysql.com/doc/refman/8.0/en/converting-tables-to-innodb.html)

如果你想把MyISAM表转换为InnoDB表从而获得更高的可靠性和可扩展性，在转换之前你需要回顾一下这里的指导和提示。

> **Note**

> 旧版本MySQL分区的MyISAM表和MySQL8.0是不兼容的。这类表在转换之前需要做一定的处理，要么移除分区，要么把它们转换成InnoDB表。查看`第23.6.2节 存储引擎的分区限制`获得更多信息。

- 调整为MyISAM和InnoDB存储引擎的内存使用
- 处理太长或太短的事务
- 处理死锁
- 规划存储布局
- 转换已有的表
- 克隆表结构
- 转换已有的数据
- 存储引擎必备条件
- 为每一张表定义主键
- 考虑应用的性能
- 理解InnoDB表相关的文件

##### 调整为MyISAM和InnoDB存储引擎的内存使用

当你从MyISAM表转换时，调低 `key_buffer_size`配置选项的值来释放不再使用的内存空间。增加`innodb_buffer_pool_size`的配置值，该配置在InnoDB中承担了和`key_buffer_size`相类似的角色。InnoDB的buffer pool同时缓存数据和索引来加速查询和保存查询结构在内存中以便重用。查看`第8.12.3.1节`以了解如何配置buffer pool大小。

##### 处理太长或太短的事务

因为MyISAM表不支持事务，你应该不需要过度关注`autocommit`配置和`COMMIT`及`ROLLBACK`语句。这些关键词对允许多个会话并发读写InnoDB表是非常重要的，并对写负载高的场景提供了高度的可扩展性。

当一个事务开启时，系统保存一个事务开启时看到的数据快照，当因一个有问题的事务运行导致系统增删改数百万行数据时会对数据库造成极大的压力。因此，注意避免事务运行时间过长：

- 如果你正在使用mysql的交互模式来实验，当结束时记得总是`COMMIT`（完成修改）或`ROLLBACK`（取消修改）。关闭交互模式下的会话而不是让他们保持链接很久以免意外打开事务时间太久。

- 确保你应用中的异常处理同样在未完成更新时`ROLLBACK` 和 完成更新时`COMMIT`。

- `ROLLBACK` 是一个相对代价较大的操作，因为`INSERT`,`UPDATE`和`DELETE`操作是在`COMMIT`之前写到InnoDB表的，这种处理是建立在大多数修改最后能够成功提交而少部分会回滚的预期上。当用大量数据来实验时，避免修改大量的行然后再回滚这些变更。

- 当使用一系列的`INSERT`语句来插入大量的数据时，周期性的`COMMIT`事务来避免让事务持续数个小时。尤其是在为数仓导数据时，如果出错了，你最好清空表（用`TRUNCATE TABLE`）从头开始而不是执行`ROLLBACK`操作。

之前的小提示主要关注怎么节约由长时间的事务造成的内存和磁盘空间的浪费。然而当事务比期望的要短时，问题主要集中在过高的I/O。伴随着每一个`COMMIT`，MySQL需要确保每一个事务都安全的记录到磁盘上，这都需要一些I/O。

- 对于InnoDB表的大多数操作，你应该设置`autocommit=0`。从效率的角度来说，这避免了大量接连不断的`INSERT`，`UPDATE`或`DELETE`语句所造成的不必要的I/O。从安全的角度来说，这允许你在mysql命令行或者在你的应用程序的异常处理中执行了错误的操作时，可以使用`ROLLBACK`来恢复丢失或者错乱的数据。

- 当运行的查询是用来生成报告或者分析统计时，设置`autocommit=1`是合适的。在这种情况下，对于`COMMIT`和`ROLLBACK`是没有性能损耗的，并且InnoDB能够自动的优化只读负载。

- 如果你执行了一系列的更新，最后使用一个`COMMIT`来提交所有的更改。例如，如果你插入相关的信息到几张表中，执行完所有的更改后再执行一个`COMMIT`。或者你连续运行了很多`INSERT`语句，当所有的数据都载入后再执行一个`COMMIT`；当你正在执行百万级的`INSERT`语句时，尽可能通过每执行1万条或者10万条记录后就执行一次`COMMIT`来拆分庞大的事务，以避免事务增长的过大。

- 记住即使是一个`SELECT`语句也会开启一个事务，因此在交互模式会话中执行了一些报告或者debugging查询后，要么执行`COMMIT`要么关闭mysql会话。

##### 处理死锁

你也许能在MySQL的error log或者`SHOW ENGINE InnoDB STATUS`的输出中看到`deadlocks`相关的信息。不要管这可怕的名字，死锁对于InnoDB表来说并不是严重的问题，并且通常不需要修正。当两个事务开始修改多张表的时候，用不同的顺序访问表，它们可以达到一种状态，每个事务都在等待对方的锁且任务一方都拿不到锁。当`deadlock detection`是开启（默认是开启的）的时候，MySQL 立即会检测到这种情况并取消（rools back）“较小的”的事务，让另一个事务执行。如果使用`innodb_deadlock_detect`配置选项禁用死锁检测，遇到死锁的情况下InnoDB会根据`innodb_lock_wait_timeout`设置来回滚事务。

另一方面，你的应用需要错误处理来重启因死锁被强制取消的事务。当你重新发起和之前相同的SQL语句，原来的计时问题不再有用。要么其他的事务已经结束，然后你的事务可以继续处理，要么其他的事务仍在继续执行，然后你的事务一直等待到它结束。

如果死锁警告重复不断的出现，你可能需要检测你的应用代码来重新排列SQL查询的顺序以保持事务之间的执行顺序保持一致，或者缩短你的事务。你可以开启`innodb_print_all_deadlocks`选项来测试从而可以在MySQL的error log中看到所有的死锁警告，而不是在`SHOW ENGINE INNODB STATUS`输出中仅仅看到的最近的死锁警告。

更多的信息，请查看`第15.7.5节 InnoDB中的死锁`

##### 规划存储布局

为了获得InnoDB表的最好性能，你可以调整一系列存储布局相关的参数。

当你转换的MyISAM表是非常庞大、访问频繁时且存储重要数据时，考察和考虑`innodb_file_per_table`和`innodb_page_size`配置选项，和`CREATE TABLE`语句的`ROW_FORMAT`和`KEY_BLOCK_SIZE`的子句。

在你初始测试时，最重要的设置是`innodb_file_per_table`。当这个设置被打开时，新的InnoDB表是隐式使用file-per-table表空间来创建的。与InnoDB系统表空间对比，当表被删除或清空时file-per-table表空间允许操作系统重新使用。file-per-table表空间同时支持DYNAMIC和COMPRESSED行格式，相关的特性包括表压缩，对长的可变长度的列的高效的跨页存储，以及大的索引前缀。更多信息，请查看`第15.6.3.2节 file-per-table 表空间`。

你也可以存储InnoDB表在通用共享表空间，此空间支持多种表和所有的行格式。更多信息请查看`第15.6.3.3节 通用表空间`。
